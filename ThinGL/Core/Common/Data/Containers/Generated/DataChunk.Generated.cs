






// AUTOGENERATED FILE: Do not edit directly, instead edit MemoryChunk.tt
#if !USE_OLD_DATA_CHUNK
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Numerics;

using ThinGin.Core.Common.Enums;


namespace ThinGin.Core.Common.Data
{
	public partial class DataChunk : IComparable<DataChunk>, IEquatable<DataChunk>
	{
#region Constants
		public const int SIZE_BYTE = sizeof(byte);
		public const int SIZE_SBYTE = sizeof(sbyte);
		public const int SIZE_USHORT = sizeof(ushort);
		public const int SIZE_SHORT = sizeof(short);
		public const int SIZE_UINT = sizeof(uint);
		public const int SIZE_INT = sizeof(int);
		public const int SIZE_FLOAT = sizeof(float);
		public const int SIZE_DOUBLE = sizeof(double);
#endregion

#region Constructors (Series)
		#region Byte
		public DataChunk(byte v0)
		{
			Layout = DataChunkDescriptor.BYTE1;
			Type = EValueType.UInt8;
			const int _size = SIZE_BYTE * 1;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					byte* pDst = (byte*)ptr;
					pDst[0] = v0;
				}
			}
			min = max = (int)v0;
		}

		public DataChunk(byte v0, byte v1)
		{
			Layout = DataChunkDescriptor.BYTE2;
			Type = EValueType.UInt8;
			const int _size = SIZE_BYTE * 2;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					byte* pDst = (byte*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
		}

		public DataChunk(byte v0, byte v1, byte v2)
		{
			Layout = DataChunkDescriptor.BYTE3;
			Type = EValueType.UInt8;
			const int _size = SIZE_BYTE * 3;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					byte* pDst = (byte*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
		}

		public DataChunk(byte v0, byte v1, byte v2, byte v3)
		{
			Layout = DataChunkDescriptor.BYTE4;
			Type = EValueType.UInt8;
			const int _size = SIZE_BYTE * 4;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					byte* pDst = (byte*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
					pDst[3] = v3;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
				_adjust_min_max(v3);
		}

		#endregion
		#region SByte
		public DataChunk(sbyte v0)
		{
			Layout = DataChunkDescriptor.SBYTE1;
			Type = EValueType.Int8;
			const int _size = SIZE_SBYTE * 1;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					sbyte* pDst = (sbyte*)ptr;
					pDst[0] = v0;
				}
			}
			min = max = (int)v0;
		}

		public DataChunk(sbyte v0, sbyte v1)
		{
			Layout = DataChunkDescriptor.SBYTE2;
			Type = EValueType.Int8;
			const int _size = SIZE_SBYTE * 2;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					sbyte* pDst = (sbyte*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
		}

		public DataChunk(sbyte v0, sbyte v1, sbyte v2)
		{
			Layout = DataChunkDescriptor.SBYTE3;
			Type = EValueType.Int8;
			const int _size = SIZE_SBYTE * 3;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					sbyte* pDst = (sbyte*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
		}

		public DataChunk(sbyte v0, sbyte v1, sbyte v2, sbyte v3)
		{
			Layout = DataChunkDescriptor.SBYTE4;
			Type = EValueType.Int8;
			const int _size = SIZE_SBYTE * 4;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					sbyte* pDst = (sbyte*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
					pDst[3] = v3;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
				_adjust_min_max(v3);
		}

		#endregion
		#region UShort
		public DataChunk(ushort v0)
		{
			Layout = DataChunkDescriptor.USHORT1;
			Type = EValueType.UInt16;
			const int _size = SIZE_USHORT * 1;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					ushort* pDst = (ushort*)ptr;
					pDst[0] = v0;
				}
			}
			min = max = (int)v0;
		}

		public DataChunk(ushort v0, ushort v1)
		{
			Layout = DataChunkDescriptor.USHORT2;
			Type = EValueType.UInt16;
			const int _size = SIZE_USHORT * 2;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					ushort* pDst = (ushort*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
		}

		public DataChunk(ushort v0, ushort v1, ushort v2)
		{
			Layout = DataChunkDescriptor.USHORT3;
			Type = EValueType.UInt16;
			const int _size = SIZE_USHORT * 3;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					ushort* pDst = (ushort*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
		}

		public DataChunk(ushort v0, ushort v1, ushort v2, ushort v3)
		{
			Layout = DataChunkDescriptor.USHORT4;
			Type = EValueType.UInt16;
			const int _size = SIZE_USHORT * 4;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					ushort* pDst = (ushort*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
					pDst[3] = v3;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
				_adjust_min_max(v3);
		}

		#endregion
		#region Short
		public DataChunk(short v0)
		{
			Layout = DataChunkDescriptor.SHORT1;
			Type = EValueType.Int16;
			const int _size = SIZE_SHORT * 1;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					short* pDst = (short*)ptr;
					pDst[0] = v0;
				}
			}
			min = max = (int)v0;
		}

		public DataChunk(short v0, short v1)
		{
			Layout = DataChunkDescriptor.SHORT2;
			Type = EValueType.Int16;
			const int _size = SIZE_SHORT * 2;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					short* pDst = (short*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
		}

		public DataChunk(short v0, short v1, short v2)
		{
			Layout = DataChunkDescriptor.SHORT3;
			Type = EValueType.Int16;
			const int _size = SIZE_SHORT * 3;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					short* pDst = (short*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
		}

		public DataChunk(short v0, short v1, short v2, short v3)
		{
			Layout = DataChunkDescriptor.SHORT4;
			Type = EValueType.Int16;
			const int _size = SIZE_SHORT * 4;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					short* pDst = (short*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
					pDst[3] = v3;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
				_adjust_min_max(v3);
		}

		#endregion
		#region UInt
		public DataChunk(uint v0)
		{
			Layout = DataChunkDescriptor.UINT1;
			Type = EValueType.UInt32;
			const int _size = SIZE_UINT * 1;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					uint* pDst = (uint*)ptr;
					pDst[0] = v0;
				}
			}
			min = max = (int)v0;
		}

		public DataChunk(uint v0, uint v1)
		{
			Layout = DataChunkDescriptor.UINT2;
			Type = EValueType.UInt32;
			const int _size = SIZE_UINT * 2;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					uint* pDst = (uint*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
		}

		public DataChunk(uint v0, uint v1, uint v2)
		{
			Layout = DataChunkDescriptor.UINT3;
			Type = EValueType.UInt32;
			const int _size = SIZE_UINT * 3;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					uint* pDst = (uint*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
		}

		public DataChunk(uint v0, uint v1, uint v2, uint v3)
		{
			Layout = DataChunkDescriptor.UINT4;
			Type = EValueType.UInt32;
			const int _size = SIZE_UINT * 4;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					uint* pDst = (uint*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
					pDst[3] = v3;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
				_adjust_min_max(v3);
		}

		#endregion
		#region Int
		public DataChunk(int v0)
		{
			Layout = DataChunkDescriptor.INT1;
			Type = EValueType.Int32;
			const int _size = SIZE_INT * 1;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					int* pDst = (int*)ptr;
					pDst[0] = v0;
				}
			}
			min = max = (int)v0;
		}

		public DataChunk(int v0, int v1)
		{
			Layout = DataChunkDescriptor.INT2;
			Type = EValueType.Int32;
			const int _size = SIZE_INT * 2;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					int* pDst = (int*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
		}

		public DataChunk(int v0, int v1, int v2)
		{
			Layout = DataChunkDescriptor.INT3;
			Type = EValueType.Int32;
			const int _size = SIZE_INT * 3;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					int* pDst = (int*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
		}

		public DataChunk(int v0, int v1, int v2, int v3)
		{
			Layout = DataChunkDescriptor.INT4;
			Type = EValueType.Int32;
			const int _size = SIZE_INT * 4;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					int* pDst = (int*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
					pDst[3] = v3;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
				_adjust_min_max(v3);
		}

		#endregion
		#region Float
		public DataChunk(float v0)
		{
			Layout = DataChunkDescriptor.FLOAT1;
			Type = EValueType.Float32;
			const int _size = SIZE_FLOAT * 1;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					float* pDst = (float*)ptr;
					pDst[0] = v0;
				}
			}
			min = max = (int)v0;
		}

		public DataChunk(float v0, float v1)
		{
			Layout = DataChunkDescriptor.FLOAT2;
			Type = EValueType.Float32;
			const int _size = SIZE_FLOAT * 2;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					float* pDst = (float*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
		}

		public DataChunk(float v0, float v1, float v2)
		{
			Layout = DataChunkDescriptor.FLOAT3;
			Type = EValueType.Float32;
			const int _size = SIZE_FLOAT * 3;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					float* pDst = (float*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
		}

		public DataChunk(float v0, float v1, float v2, float v3)
		{
			Layout = DataChunkDescriptor.FLOAT4;
			Type = EValueType.Float32;
			const int _size = SIZE_FLOAT * 4;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					float* pDst = (float*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
					pDst[3] = v3;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
				_adjust_min_max(v3);
		}

		#endregion
		#region Double
		public DataChunk(double v0)
		{
			Layout = DataChunkDescriptor.DOUBLE1;
			Type = EValueType.DOUBLE;
			const int _size = SIZE_DOUBLE * 1;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					double* pDst = (double*)ptr;
					pDst[0] = v0;
				}
			}
			min = max = (int)v0;
		}

		public DataChunk(double v0, double v1)
		{
			Layout = DataChunkDescriptor.DOUBLE2;
			Type = EValueType.DOUBLE;
			const int _size = SIZE_DOUBLE * 2;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					double* pDst = (double*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
		}

		public DataChunk(double v0, double v1, double v2)
		{
			Layout = DataChunkDescriptor.DOUBLE3;
			Type = EValueType.DOUBLE;
			const int _size = SIZE_DOUBLE * 3;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					double* pDst = (double*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
		}

		public DataChunk(double v0, double v1, double v2, double v3)
		{
			Layout = DataChunkDescriptor.DOUBLE4;
			Type = EValueType.DOUBLE;
			const int _size = SIZE_DOUBLE * 4;
			Data = new byte[_size];

			unsafe
			{
				fixed (byte* ptr = Data)
				{
					double* pDst = (double*)ptr;
					pDst[0] = v0;
					pDst[1] = v1;
					pDst[2] = v2;
					pDst[3] = v3;
				}
			}
			min = max = (int)v0;
				_adjust_min_max(v1);
				_adjust_min_max(v2);
				_adjust_min_max(v3);
		}

		#endregion
#endregion

#region Constructors (Array)
		#region Byte
		public DataChunk(in byte[] v0)
		{

			Layout = v0.Length switch
			{
				1 => DataChunkDescriptor.BYTE1,
				2 => DataChunkDescriptor.BYTE2,
				3 => DataChunkDescriptor.BYTE3,
				4 => DataChunkDescriptor.BYTE4,
				_ => new DataChunkDescriptor(v0.Length, EValueType.UInt8)
			};
			Type = EValueType.UInt8;
			Data = new byte[SIZE_BYTE * v0.Length];

			unsafe
			{
				fixed (byte *pDst = Data)
				{
					fixed (byte* pSrc = v0)
					{
						Buffer.MemoryCopy((void*)pSrc, (void*)pDst, Data.Length, Data.Length);
					}
				}
			}

			min = max = (int)v0[0];
			for (int i = 1; i < v0.Length; i++)
			{
				_adjust_min_max(v0[i]);
			}
		}

		#endregion
		#region SByte
		public DataChunk(in sbyte[] v0)
		{

			Layout = v0.Length switch
			{
				1 => DataChunkDescriptor.SBYTE1,
				2 => DataChunkDescriptor.SBYTE2,
				3 => DataChunkDescriptor.SBYTE3,
				4 => DataChunkDescriptor.SBYTE4,
				_ => new DataChunkDescriptor(v0.Length, EValueType.Int8)
			};
			Type = EValueType.Int8;
			Data = new byte[SIZE_SBYTE * v0.Length];

			unsafe
			{
				fixed (byte *pDst = Data)
				{
					fixed (sbyte* pSrc = v0)
					{
						Buffer.MemoryCopy((void*)pSrc, (void*)pDst, Data.Length, Data.Length);
					}
				}
			}

			min = max = (int)v0[0];
			for (int i = 1; i < v0.Length; i++)
			{
				_adjust_min_max(v0[i]);
			}
		}

		#endregion
		#region UShort
		public DataChunk(in ushort[] v0)
		{

			Layout = v0.Length switch
			{
				1 => DataChunkDescriptor.USHORT1,
				2 => DataChunkDescriptor.USHORT2,
				3 => DataChunkDescriptor.USHORT3,
				4 => DataChunkDescriptor.USHORT4,
				_ => new DataChunkDescriptor(v0.Length, EValueType.UInt16)
			};
			Type = EValueType.UInt16;
			Data = new byte[SIZE_USHORT * v0.Length];

			unsafe
			{
				fixed (byte *pDst = Data)
				{
					fixed (ushort* pSrc = v0)
					{
						Buffer.MemoryCopy((void*)pSrc, (void*)pDst, Data.Length, Data.Length);
					}
				}
			}

			min = max = (int)v0[0];
			for (int i = 1; i < v0.Length; i++)
			{
				_adjust_min_max(v0[i]);
			}
		}

		#endregion
		#region Short
		public DataChunk(in short[] v0)
		{

			Layout = v0.Length switch
			{
				1 => DataChunkDescriptor.SHORT1,
				2 => DataChunkDescriptor.SHORT2,
				3 => DataChunkDescriptor.SHORT3,
				4 => DataChunkDescriptor.SHORT4,
				_ => new DataChunkDescriptor(v0.Length, EValueType.Int16)
			};
			Type = EValueType.Int16;
			Data = new byte[SIZE_SHORT * v0.Length];

			unsafe
			{
				fixed (byte *pDst = Data)
				{
					fixed (short* pSrc = v0)
					{
						Buffer.MemoryCopy((void*)pSrc, (void*)pDst, Data.Length, Data.Length);
					}
				}
			}

			min = max = (int)v0[0];
			for (int i = 1; i < v0.Length; i++)
			{
				_adjust_min_max(v0[i]);
			}
		}

		#endregion
		#region UInt
		public DataChunk(in uint[] v0)
		{

			Layout = v0.Length switch
			{
				1 => DataChunkDescriptor.UINT1,
				2 => DataChunkDescriptor.UINT2,
				3 => DataChunkDescriptor.UINT3,
				4 => DataChunkDescriptor.UINT4,
				_ => new DataChunkDescriptor(v0.Length, EValueType.UInt32)
			};
			Type = EValueType.UInt32;
			Data = new byte[SIZE_UINT * v0.Length];

			unsafe
			{
				fixed (byte *pDst = Data)
				{
					fixed (uint* pSrc = v0)
					{
						Buffer.MemoryCopy((void*)pSrc, (void*)pDst, Data.Length, Data.Length);
					}
				}
			}

			min = max = (int)v0[0];
			for (int i = 1; i < v0.Length; i++)
			{
				_adjust_min_max(v0[i]);
			}
		}

		#endregion
		#region Int
		public DataChunk(in int[] v0)
		{

			Layout = v0.Length switch
			{
				1 => DataChunkDescriptor.INT1,
				2 => DataChunkDescriptor.INT2,
				3 => DataChunkDescriptor.INT3,
				4 => DataChunkDescriptor.INT4,
				_ => new DataChunkDescriptor(v0.Length, EValueType.Int32)
			};
			Type = EValueType.Int32;
			Data = new byte[SIZE_INT * v0.Length];

			unsafe
			{
				fixed (byte *pDst = Data)
				{
					fixed (int* pSrc = v0)
					{
						Buffer.MemoryCopy((void*)pSrc, (void*)pDst, Data.Length, Data.Length);
					}
				}
			}

			min = max = (int)v0[0];
			for (int i = 1; i < v0.Length; i++)
			{
				_adjust_min_max(v0[i]);
			}
		}

		#endregion
		#region Float
		public DataChunk(in float[] v0)
		{

			Layout = v0.Length switch
			{
				1 => DataChunkDescriptor.FLOAT1,
				2 => DataChunkDescriptor.FLOAT2,
				3 => DataChunkDescriptor.FLOAT3,
				4 => DataChunkDescriptor.FLOAT4,
				_ => new DataChunkDescriptor(v0.Length, EValueType.Float32)
			};
			Type = EValueType.Float32;
			Data = new byte[SIZE_FLOAT * v0.Length];

			unsafe
			{
				fixed (byte *pDst = Data)
				{
					fixed (float* pSrc = v0)
					{
						Buffer.MemoryCopy((void*)pSrc, (void*)pDst, Data.Length, Data.Length);
					}
				}
			}

			min = max = (int)v0[0];
			for (int i = 1; i < v0.Length; i++)
			{
				_adjust_min_max(v0[i]);
			}
		}

		#endregion
		#region Double
		public DataChunk(in double[] v0)
		{

			Layout = v0.Length switch
			{
				1 => DataChunkDescriptor.DOUBLE1,
				2 => DataChunkDescriptor.DOUBLE2,
				3 => DataChunkDescriptor.DOUBLE3,
				4 => DataChunkDescriptor.DOUBLE4,
				_ => new DataChunkDescriptor(v0.Length, EValueType.DOUBLE)
			};
			Type = EValueType.DOUBLE;
			Data = new byte[SIZE_DOUBLE * v0.Length];

			unsafe
			{
				fixed (byte *pDst = Data)
				{
					fixed (double* pSrc = v0)
					{
						Buffer.MemoryCopy((void*)pSrc, (void*)pDst, Data.Length, Data.Length);
					}
				}
			}

			min = max = (int)v0[0];
			for (int i = 1; i < v0.Length; i++)
			{
				_adjust_min_max(v0[i]);
			}
		}

		#endregion
#endregion

#region Conversions
		public byte[] ToByte()
		{
			var result = new byte[Count];
			unsafe
			{
				switch(Type)
				{
					case EValueType.UInt8: { _vt_quick_cast__byte_to_byte(result, Count); } break;
					case EValueType.Int8: { _vt_quick_cast__sbyte_to_byte(result, Count); } break;
					case EValueType.UInt16: { _vt_quick_cast__ushort_to_byte(result, Count); } break;
					case EValueType.Int16: { _vt_quick_cast__short_to_byte(result, Count); } break;
					case EValueType.UInt32: { _vt_quick_cast__uint_to_byte(result, Count); } break;
					case EValueType.Int32: { _vt_quick_cast__int_to_byte(result, Count); } break;
					case EValueType.Float32: { _vt_quick_cast__float_to_byte(result, Count); } break;
					case EValueType.DOUBLE: { _vt_quick_cast__double_to_byte(result, Count); } break;
				}
			}
			return result;
		}

		public sbyte[] ToSByte()
		{
			var result = new sbyte[Count];
			unsafe
			{
				switch(Type)
				{
					case EValueType.UInt8: { _vt_quick_cast__byte_to_sbyte(result, Count); } break;
					case EValueType.Int8: { _vt_quick_cast__sbyte_to_sbyte(result, Count); } break;
					case EValueType.UInt16: { _vt_quick_cast__ushort_to_sbyte(result, Count); } break;
					case EValueType.Int16: { _vt_quick_cast__short_to_sbyte(result, Count); } break;
					case EValueType.UInt32: { _vt_quick_cast__uint_to_sbyte(result, Count); } break;
					case EValueType.Int32: { _vt_quick_cast__int_to_sbyte(result, Count); } break;
					case EValueType.Float32: { _vt_quick_cast__float_to_sbyte(result, Count); } break;
					case EValueType.DOUBLE: { _vt_quick_cast__double_to_sbyte(result, Count); } break;
				}
			}
			return result;
		}

		public ushort[] ToUShort()
		{
			var result = new ushort[Count];
			unsafe
			{
				switch(Type)
				{
					case EValueType.UInt8: { _vt_quick_cast__byte_to_ushort(result, Count); } break;
					case EValueType.Int8: { _vt_quick_cast__sbyte_to_ushort(result, Count); } break;
					case EValueType.UInt16: { _vt_quick_cast__ushort_to_ushort(result, Count); } break;
					case EValueType.Int16: { _vt_quick_cast__short_to_ushort(result, Count); } break;
					case EValueType.UInt32: { _vt_quick_cast__uint_to_ushort(result, Count); } break;
					case EValueType.Int32: { _vt_quick_cast__int_to_ushort(result, Count); } break;
					case EValueType.Float32: { _vt_quick_cast__float_to_ushort(result, Count); } break;
					case EValueType.DOUBLE: { _vt_quick_cast__double_to_ushort(result, Count); } break;
				}
			}
			return result;
		}

		public short[] ToShort()
		{
			var result = new short[Count];
			unsafe
			{
				switch(Type)
				{
					case EValueType.UInt8: { _vt_quick_cast__byte_to_short(result, Count); } break;
					case EValueType.Int8: { _vt_quick_cast__sbyte_to_short(result, Count); } break;
					case EValueType.UInt16: { _vt_quick_cast__ushort_to_short(result, Count); } break;
					case EValueType.Int16: { _vt_quick_cast__short_to_short(result, Count); } break;
					case EValueType.UInt32: { _vt_quick_cast__uint_to_short(result, Count); } break;
					case EValueType.Int32: { _vt_quick_cast__int_to_short(result, Count); } break;
					case EValueType.Float32: { _vt_quick_cast__float_to_short(result, Count); } break;
					case EValueType.DOUBLE: { _vt_quick_cast__double_to_short(result, Count); } break;
				}
			}
			return result;
		}

		public uint[] ToUInt()
		{
			var result = new uint[Count];
			unsafe
			{
				switch(Type)
				{
					case EValueType.UInt8: { _vt_quick_cast__byte_to_uint(result, Count); } break;
					case EValueType.Int8: { _vt_quick_cast__sbyte_to_uint(result, Count); } break;
					case EValueType.UInt16: { _vt_quick_cast__ushort_to_uint(result, Count); } break;
					case EValueType.Int16: { _vt_quick_cast__short_to_uint(result, Count); } break;
					case EValueType.UInt32: { _vt_quick_cast__uint_to_uint(result, Count); } break;
					case EValueType.Int32: { _vt_quick_cast__int_to_uint(result, Count); } break;
					case EValueType.Float32: { _vt_quick_cast__float_to_uint(result, Count); } break;
					case EValueType.DOUBLE: { _vt_quick_cast__double_to_uint(result, Count); } break;
				}
			}
			return result;
		}

		public int[] ToInt()
		{
			var result = new int[Count];
			unsafe
			{
				switch(Type)
				{
					case EValueType.UInt8: { _vt_quick_cast__byte_to_int(result, Count); } break;
					case EValueType.Int8: { _vt_quick_cast__sbyte_to_int(result, Count); } break;
					case EValueType.UInt16: { _vt_quick_cast__ushort_to_int(result, Count); } break;
					case EValueType.Int16: { _vt_quick_cast__short_to_int(result, Count); } break;
					case EValueType.UInt32: { _vt_quick_cast__uint_to_int(result, Count); } break;
					case EValueType.Int32: { _vt_quick_cast__int_to_int(result, Count); } break;
					case EValueType.Float32: { _vt_quick_cast__float_to_int(result, Count); } break;
					case EValueType.DOUBLE: { _vt_quick_cast__double_to_int(result, Count); } break;
				}
			}
			return result;
		}

		public float[] ToFloat()
		{
			var result = new float[Count];
			unsafe
			{
				switch(Type)
				{
					case EValueType.UInt8: { _vt_quick_cast__byte_to_float(result, Count); } break;
					case EValueType.Int8: { _vt_quick_cast__sbyte_to_float(result, Count); } break;
					case EValueType.UInt16: { _vt_quick_cast__ushort_to_float(result, Count); } break;
					case EValueType.Int16: { _vt_quick_cast__short_to_float(result, Count); } break;
					case EValueType.UInt32: { _vt_quick_cast__uint_to_float(result, Count); } break;
					case EValueType.Int32: { _vt_quick_cast__int_to_float(result, Count); } break;
					case EValueType.Float32: { _vt_quick_cast__float_to_float(result, Count); } break;
					case EValueType.DOUBLE: { _vt_quick_cast__double_to_float(result, Count); } break;
				}
			}
			return result;
		}

		public double[] ToDouble()
		{
			var result = new double[Count];
			unsafe
			{
				switch(Type)
				{
					case EValueType.UInt8: { _vt_quick_cast__byte_to_double(result, Count); } break;
					case EValueType.Int8: { _vt_quick_cast__sbyte_to_double(result, Count); } break;
					case EValueType.UInt16: { _vt_quick_cast__ushort_to_double(result, Count); } break;
					case EValueType.Int16: { _vt_quick_cast__short_to_double(result, Count); } break;
					case EValueType.UInt32: { _vt_quick_cast__uint_to_double(result, Count); } break;
					case EValueType.Int32: { _vt_quick_cast__int_to_double(result, Count); } break;
					case EValueType.Float32: { _vt_quick_cast__float_to_double(result, Count); } break;
					case EValueType.DOUBLE: { _vt_quick_cast__double_to_double(result, Count); } break;
				}
			}
			return result;
		}

#endregion

#region Low-Level Casting
		private unsafe void _vt_quick_cast__byte_to_byte(byte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (byte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (byte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__byte_to_sbyte(sbyte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (byte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (sbyte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__byte_to_ushort(ushort[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (byte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (ushort)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__byte_to_short(short[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (byte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (short)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__byte_to_uint(uint[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (byte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (uint)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__byte_to_int(int[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (byte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (int)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__byte_to_float(float[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (byte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (float)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__byte_to_double(double[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (byte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (double)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__sbyte_to_byte(byte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (sbyte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (byte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__sbyte_to_sbyte(sbyte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (sbyte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (sbyte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__sbyte_to_ushort(ushort[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (sbyte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (ushort)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__sbyte_to_short(short[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (sbyte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (short)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__sbyte_to_uint(uint[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (sbyte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (uint)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__sbyte_to_int(int[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (sbyte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (int)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__sbyte_to_float(float[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (sbyte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (float)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__sbyte_to_double(double[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (sbyte*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (double)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__ushort_to_byte(byte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (ushort*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (byte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__ushort_to_sbyte(sbyte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (ushort*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (sbyte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__ushort_to_ushort(ushort[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (ushort*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (ushort)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__ushort_to_short(short[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (ushort*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (short)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__ushort_to_uint(uint[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (ushort*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (uint)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__ushort_to_int(int[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (ushort*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (int)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__ushort_to_float(float[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (ushort*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (float)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__ushort_to_double(double[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (ushort*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (double)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__short_to_byte(byte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (short*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (byte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__short_to_sbyte(sbyte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (short*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (sbyte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__short_to_ushort(ushort[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (short*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (ushort)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__short_to_short(short[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (short*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (short)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__short_to_uint(uint[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (short*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (uint)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__short_to_int(int[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (short*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (int)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__short_to_float(float[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (short*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (float)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__short_to_double(double[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (short*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (double)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__uint_to_byte(byte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (uint*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (byte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__uint_to_sbyte(sbyte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (uint*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (sbyte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__uint_to_ushort(ushort[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (uint*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (ushort)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__uint_to_short(short[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (uint*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (short)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__uint_to_uint(uint[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (uint*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (uint)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__uint_to_int(int[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (uint*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (int)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__uint_to_float(float[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (uint*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (float)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__uint_to_double(double[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (uint*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (double)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__int_to_byte(byte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (int*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (byte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__int_to_sbyte(sbyte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (int*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (sbyte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__int_to_ushort(ushort[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (int*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (ushort)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__int_to_short(short[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (int*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (short)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__int_to_uint(uint[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (int*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (uint)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__int_to_int(int[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (int*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (int)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__int_to_float(float[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (int*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (float)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__int_to_double(double[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (int*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (double)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__float_to_byte(byte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (float*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (byte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__float_to_sbyte(sbyte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (float*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (sbyte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__float_to_ushort(ushort[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (float*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (ushort)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__float_to_short(short[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (float*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (short)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__float_to_uint(uint[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (float*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (uint)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__float_to_int(int[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (float*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (int)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__float_to_float(float[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (float*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (float)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__float_to_double(double[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (float*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (double)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__double_to_byte(byte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (double*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (byte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__double_to_sbyte(sbyte[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (double*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (sbyte)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__double_to_ushort(ushort[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (double*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (ushort)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__double_to_short(short[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (double*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (short)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__double_to_uint(uint[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (double*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (uint)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__double_to_int(int[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (double*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (int)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__double_to_float(float[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (double*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (float)(tPtr[i]);
				}
			}
		}

		private unsafe void _vt_quick_cast__double_to_double(double[] Destination, int Count)
		{
			fixed (byte* dPtr = Data)
			{
				var tPtr = (double*)dPtr;
				for (int i = 0; i < Count; i++)
				{
					Destination[i] = (double)(tPtr[i]);
				}
			}
		}

#endregion

#region Value Retreival
		public byte GetByte(int index) { unsafe { fixed (byte* ptr = Data) { return ((byte*)ptr)[index]; } } }
		// public byte GetByte(int index) { unsafe { fixed (byte* ptr = &Data[index * SIZE_BYTE]) { return *(byte*)ptr; } } }
		public sbyte GetSByte(int index) { unsafe { fixed (byte* ptr = Data) { return ((sbyte*)ptr)[index]; } } }
		// public sbyte GetSByte(int index) { unsafe { fixed (byte* ptr = &Data[index * SIZE_SBYTE]) { return *(sbyte*)ptr; } } }
		public ushort GetUShort(int index) { unsafe { fixed (byte* ptr = Data) { return ((ushort*)ptr)[index]; } } }
		// public ushort GetUShort(int index) { unsafe { fixed (byte* ptr = &Data[index * SIZE_USHORT]) { return *(ushort*)ptr; } } }
		public short GetShort(int index) { unsafe { fixed (byte* ptr = Data) { return ((short*)ptr)[index]; } } }
		// public short GetShort(int index) { unsafe { fixed (byte* ptr = &Data[index * SIZE_SHORT]) { return *(short*)ptr; } } }
		public uint GetUInt(int index) { unsafe { fixed (byte* ptr = Data) { return ((uint*)ptr)[index]; } } }
		// public uint GetUInt(int index) { unsafe { fixed (byte* ptr = &Data[index * SIZE_UINT]) { return *(uint*)ptr; } } }
		public int GetInt(int index) { unsafe { fixed (byte* ptr = Data) { return ((int*)ptr)[index]; } } }
		// public int GetInt(int index) { unsafe { fixed (byte* ptr = &Data[index * SIZE_INT]) { return *(int*)ptr; } } }
		public float GetFloat(int index) { unsafe { fixed (byte* ptr = Data) { return ((float*)ptr)[index]; } } }
		// public float GetFloat(int index) { unsafe { fixed (byte* ptr = &Data[index * SIZE_FLOAT]) { return *(float*)ptr; } } }
		public double GetDouble(int index) { unsafe { fixed (byte* ptr = Data) { return ((double*)ptr)[index]; } } }
		// public double GetDouble(int index) { unsafe { fixed (byte* ptr = &Data[index * SIZE_DOUBLE]) { return *(double*)ptr; } } }
#endregion

#region IEquatable
		public bool Equals(DataChunk other)
        {
			return CompareTo(other) == 0;
        }
#endregion

#region IComparable
		public int CompareTo(DataChunk other)
        {
			if (other is null)
			{
				throw new ArgumentNullException(nameof(other));
			}

			var TypeLeft = this.Type;
			var TypeRight = other.Type;
			switch (TypeLeft, TypeRight)
			{
				case (EValueType.UInt8, EValueType.UInt8):
					return _vt_high_perf_compare_byte__byte(other);
				case (EValueType.UInt8, EValueType.Int8):
					return _vt_high_perf_compare_byte__sbyte(other);
				case (EValueType.UInt8, EValueType.UInt16):
					return _vt_high_perf_compare_byte__ushort(other);
				case (EValueType.UInt8, EValueType.Int16):
					return _vt_high_perf_compare_byte__short(other);
				case (EValueType.UInt8, EValueType.UInt32):
					return _vt_high_perf_compare_byte__uint(other);
				case (EValueType.UInt8, EValueType.Int32):
					return _vt_high_perf_compare_byte__int(other);
				case (EValueType.UInt8, EValueType.Float32):
					return _vt_high_perf_compare_byte__float(other);
				case (EValueType.UInt8, EValueType.DOUBLE):
					return _vt_high_perf_compare_byte__double(other);
				case (EValueType.Int8, EValueType.UInt8):
					return _vt_high_perf_compare_sbyte__byte(other);
				case (EValueType.Int8, EValueType.Int8):
					return _vt_high_perf_compare_sbyte__sbyte(other);
				case (EValueType.Int8, EValueType.UInt16):
					return _vt_high_perf_compare_sbyte__ushort(other);
				case (EValueType.Int8, EValueType.Int16):
					return _vt_high_perf_compare_sbyte__short(other);
				case (EValueType.Int8, EValueType.UInt32):
					return _vt_high_perf_compare_sbyte__uint(other);
				case (EValueType.Int8, EValueType.Int32):
					return _vt_high_perf_compare_sbyte__int(other);
				case (EValueType.Int8, EValueType.Float32):
					return _vt_high_perf_compare_sbyte__float(other);
				case (EValueType.Int8, EValueType.DOUBLE):
					return _vt_high_perf_compare_sbyte__double(other);
				case (EValueType.UInt16, EValueType.UInt8):
					return _vt_high_perf_compare_ushort__byte(other);
				case (EValueType.UInt16, EValueType.Int8):
					return _vt_high_perf_compare_ushort__sbyte(other);
				case (EValueType.UInt16, EValueType.UInt16):
					return _vt_high_perf_compare_ushort__ushort(other);
				case (EValueType.UInt16, EValueType.Int16):
					return _vt_high_perf_compare_ushort__short(other);
				case (EValueType.UInt16, EValueType.UInt32):
					return _vt_high_perf_compare_ushort__uint(other);
				case (EValueType.UInt16, EValueType.Int32):
					return _vt_high_perf_compare_ushort__int(other);
				case (EValueType.UInt16, EValueType.Float32):
					return _vt_high_perf_compare_ushort__float(other);
				case (EValueType.UInt16, EValueType.DOUBLE):
					return _vt_high_perf_compare_ushort__double(other);
				case (EValueType.Int16, EValueType.UInt8):
					return _vt_high_perf_compare_short__byte(other);
				case (EValueType.Int16, EValueType.Int8):
					return _vt_high_perf_compare_short__sbyte(other);
				case (EValueType.Int16, EValueType.UInt16):
					return _vt_high_perf_compare_short__ushort(other);
				case (EValueType.Int16, EValueType.Int16):
					return _vt_high_perf_compare_short__short(other);
				case (EValueType.Int16, EValueType.UInt32):
					return _vt_high_perf_compare_short__uint(other);
				case (EValueType.Int16, EValueType.Int32):
					return _vt_high_perf_compare_short__int(other);
				case (EValueType.Int16, EValueType.Float32):
					return _vt_high_perf_compare_short__float(other);
				case (EValueType.Int16, EValueType.DOUBLE):
					return _vt_high_perf_compare_short__double(other);
				case (EValueType.UInt32, EValueType.UInt8):
					return _vt_high_perf_compare_uint__byte(other);
				case (EValueType.UInt32, EValueType.Int8):
					return _vt_high_perf_compare_uint__sbyte(other);
				case (EValueType.UInt32, EValueType.UInt16):
					return _vt_high_perf_compare_uint__ushort(other);
				case (EValueType.UInt32, EValueType.Int16):
					return _vt_high_perf_compare_uint__short(other);
				case (EValueType.UInt32, EValueType.UInt32):
					return _vt_high_perf_compare_uint__uint(other);
				case (EValueType.UInt32, EValueType.Int32):
					return _vt_high_perf_compare_uint__int(other);
				case (EValueType.UInt32, EValueType.Float32):
					return _vt_high_perf_compare_uint__float(other);
				case (EValueType.UInt32, EValueType.DOUBLE):
					return _vt_high_perf_compare_uint__double(other);
				case (EValueType.Int32, EValueType.UInt8):
					return _vt_high_perf_compare_int__byte(other);
				case (EValueType.Int32, EValueType.Int8):
					return _vt_high_perf_compare_int__sbyte(other);
				case (EValueType.Int32, EValueType.UInt16):
					return _vt_high_perf_compare_int__ushort(other);
				case (EValueType.Int32, EValueType.Int16):
					return _vt_high_perf_compare_int__short(other);
				case (EValueType.Int32, EValueType.UInt32):
					return _vt_high_perf_compare_int__uint(other);
				case (EValueType.Int32, EValueType.Int32):
					return _vt_high_perf_compare_int__int(other);
				case (EValueType.Int32, EValueType.Float32):
					return _vt_high_perf_compare_int__float(other);
				case (EValueType.Int32, EValueType.DOUBLE):
					return _vt_high_perf_compare_int__double(other);
				case (EValueType.Float32, EValueType.UInt8):
					return _vt_high_perf_compare_float__byte(other);
				case (EValueType.Float32, EValueType.Int8):
					return _vt_high_perf_compare_float__sbyte(other);
				case (EValueType.Float32, EValueType.UInt16):
					return _vt_high_perf_compare_float__ushort(other);
				case (EValueType.Float32, EValueType.Int16):
					return _vt_high_perf_compare_float__short(other);
				case (EValueType.Float32, EValueType.UInt32):
					return _vt_high_perf_compare_float__uint(other);
				case (EValueType.Float32, EValueType.Int32):
					return _vt_high_perf_compare_float__int(other);
				case (EValueType.Float32, EValueType.Float32):
					return _vt_high_perf_compare_float__float(other);
				case (EValueType.Float32, EValueType.DOUBLE):
					return _vt_high_perf_compare_float__double(other);
				case (EValueType.DOUBLE, EValueType.UInt8):
					return _vt_high_perf_compare_double__byte(other);
				case (EValueType.DOUBLE, EValueType.Int8):
					return _vt_high_perf_compare_double__sbyte(other);
				case (EValueType.DOUBLE, EValueType.UInt16):
					return _vt_high_perf_compare_double__ushort(other);
				case (EValueType.DOUBLE, EValueType.Int16):
					return _vt_high_perf_compare_double__short(other);
				case (EValueType.DOUBLE, EValueType.UInt32):
					return _vt_high_perf_compare_double__uint(other);
				case (EValueType.DOUBLE, EValueType.Int32):
					return _vt_high_perf_compare_double__int(other);
				case (EValueType.DOUBLE, EValueType.Float32):
					return _vt_high_perf_compare_double__float(other);
				case (EValueType.DOUBLE, EValueType.DOUBLE):
					return _vt_high_perf_compare_double__double(other);
			}
			throw new NotImplementedException();
        }
#endregion

#region Low-Level Comparison
		private int _vt_high_perf_compare_byte__byte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					byte* pLeft = (byte*)raw_ptr_left;
					byte* pRight = (byte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_byte__sbyte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					byte* pLeft = (byte*)raw_ptr_left;
					sbyte* pRight = (sbyte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_byte__ushort(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					byte* pLeft = (byte*)raw_ptr_left;
					ushort* pRight = (ushort*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_byte__short(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					byte* pLeft = (byte*)raw_ptr_left;
					short* pRight = (short*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_byte__uint(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					byte* pLeft = (byte*)raw_ptr_left;
					uint* pRight = (uint*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_byte__int(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					byte* pLeft = (byte*)raw_ptr_left;
					int* pRight = (int*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_byte__float(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					byte* pLeft = (byte*)raw_ptr_left;
					float* pRight = (float*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_byte__double(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					byte* pLeft = (byte*)raw_ptr_left;
					double* pRight = (double*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_sbyte__byte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					sbyte* pLeft = (sbyte*)raw_ptr_left;
					byte* pRight = (byte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_sbyte__sbyte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					sbyte* pLeft = (sbyte*)raw_ptr_left;
					sbyte* pRight = (sbyte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_sbyte__ushort(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					sbyte* pLeft = (sbyte*)raw_ptr_left;
					ushort* pRight = (ushort*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_sbyte__short(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					sbyte* pLeft = (sbyte*)raw_ptr_left;
					short* pRight = (short*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_sbyte__uint(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					sbyte* pLeft = (sbyte*)raw_ptr_left;
					uint* pRight = (uint*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_sbyte__int(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					sbyte* pLeft = (sbyte*)raw_ptr_left;
					int* pRight = (int*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_sbyte__float(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					sbyte* pLeft = (sbyte*)raw_ptr_left;
					float* pRight = (float*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_sbyte__double(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					sbyte* pLeft = (sbyte*)raw_ptr_left;
					double* pRight = (double*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_ushort__byte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					ushort* pLeft = (ushort*)raw_ptr_left;
					byte* pRight = (byte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_ushort__sbyte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					ushort* pLeft = (ushort*)raw_ptr_left;
					sbyte* pRight = (sbyte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_ushort__ushort(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					ushort* pLeft = (ushort*)raw_ptr_left;
					ushort* pRight = (ushort*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_ushort__short(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					ushort* pLeft = (ushort*)raw_ptr_left;
					short* pRight = (short*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_ushort__uint(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					ushort* pLeft = (ushort*)raw_ptr_left;
					uint* pRight = (uint*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_ushort__int(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					ushort* pLeft = (ushort*)raw_ptr_left;
					int* pRight = (int*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_ushort__float(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					ushort* pLeft = (ushort*)raw_ptr_left;
					float* pRight = (float*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_ushort__double(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					ushort* pLeft = (ushort*)raw_ptr_left;
					double* pRight = (double*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_short__byte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					short* pLeft = (short*)raw_ptr_left;
					byte* pRight = (byte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_short__sbyte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					short* pLeft = (short*)raw_ptr_left;
					sbyte* pRight = (sbyte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_short__ushort(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					short* pLeft = (short*)raw_ptr_left;
					ushort* pRight = (ushort*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_short__short(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					short* pLeft = (short*)raw_ptr_left;
					short* pRight = (short*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_short__uint(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					short* pLeft = (short*)raw_ptr_left;
					uint* pRight = (uint*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_short__int(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					short* pLeft = (short*)raw_ptr_left;
					int* pRight = (int*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_short__float(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					short* pLeft = (short*)raw_ptr_left;
					float* pRight = (float*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_short__double(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					short* pLeft = (short*)raw_ptr_left;
					double* pRight = (double*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_uint__byte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					uint* pLeft = (uint*)raw_ptr_left;
					byte* pRight = (byte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_uint__sbyte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					uint* pLeft = (uint*)raw_ptr_left;
					sbyte* pRight = (sbyte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_uint__ushort(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					uint* pLeft = (uint*)raw_ptr_left;
					ushort* pRight = (ushort*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_uint__short(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					uint* pLeft = (uint*)raw_ptr_left;
					short* pRight = (short*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_uint__uint(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					uint* pLeft = (uint*)raw_ptr_left;
					uint* pRight = (uint*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_uint__int(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					uint* pLeft = (uint*)raw_ptr_left;
					int* pRight = (int*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_uint__float(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					uint* pLeft = (uint*)raw_ptr_left;
					float* pRight = (float*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_uint__double(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					uint* pLeft = (uint*)raw_ptr_left;
					double* pRight = (double*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_int__byte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					int* pLeft = (int*)raw_ptr_left;
					byte* pRight = (byte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_int__sbyte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					int* pLeft = (int*)raw_ptr_left;
					sbyte* pRight = (sbyte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_int__ushort(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					int* pLeft = (int*)raw_ptr_left;
					ushort* pRight = (ushort*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_int__short(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					int* pLeft = (int*)raw_ptr_left;
					short* pRight = (short*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_int__uint(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					int* pLeft = (int*)raw_ptr_left;
					uint* pRight = (uint*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_int__int(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					int* pLeft = (int*)raw_ptr_left;
					int* pRight = (int*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_int__float(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					int* pLeft = (int*)raw_ptr_left;
					float* pRight = (float*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_int__double(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					int* pLeft = (int*)raw_ptr_left;
					double* pRight = (double*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_float__byte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					float* pLeft = (float*)raw_ptr_left;
					byte* pRight = (byte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_float__sbyte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					float* pLeft = (float*)raw_ptr_left;
					sbyte* pRight = (sbyte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_float__ushort(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					float* pLeft = (float*)raw_ptr_left;
					ushort* pRight = (ushort*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_float__short(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					float* pLeft = (float*)raw_ptr_left;
					short* pRight = (short*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_float__uint(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					float* pLeft = (float*)raw_ptr_left;
					uint* pRight = (uint*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_float__int(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					float* pLeft = (float*)raw_ptr_left;
					int* pRight = (int*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_float__float(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					float* pLeft = (float*)raw_ptr_left;
					float* pRight = (float*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_float__double(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					float* pLeft = (float*)raw_ptr_left;
					double* pRight = (double*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_double__byte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					double* pLeft = (double*)raw_ptr_left;
					byte* pRight = (byte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_double__sbyte(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					double* pLeft = (double*)raw_ptr_left;
					sbyte* pRight = (sbyte*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_double__ushort(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					double* pLeft = (double*)raw_ptr_left;
					ushort* pRight = (ushort*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_double__short(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					double* pLeft = (double*)raw_ptr_left;
					short* pRight = (short*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_double__uint(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					double* pLeft = (double*)raw_ptr_left;
					uint* pRight = (uint*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_double__int(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					double* pLeft = (double*)raw_ptr_left;
					int* pRight = (int*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_double__float(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					double* pLeft = (double*)raw_ptr_left;
					float* pRight = (float*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
		private int _vt_high_perf_compare_double__double(DataChunk other) 
		{
			var spanLeft = this.AsSpan();
			var spanRight = other.AsSpan();
			int ItemCount = Math.Min(Count, other.Count);
			unsafe 
			{
				fixed (byte* raw_ptr_left = spanLeft, raw_ptr_right = spanRight)
				{
					double* pLeft = (double*)raw_ptr_left;
					double* pRight = (double*)raw_ptr_right;

					for (int i=0; i < ItemCount; i++)
					{
						var c = pRight[i] - pLeft[i];
						if (c != 0) 
						{
							return (int)c;
						}
					}

					return 0;
				}
			}
		}
#endregion

	}
}
#endif