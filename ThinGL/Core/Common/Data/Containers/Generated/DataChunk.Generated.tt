<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="GenericGenerators.ttinclude" once="true" #>
<#@ include file="ValueTypeGenerators.ttinclude" once="true" #>
<#@ include file="ValueTypePerf.ttinclude" once="true" #>
// AUTOGENERATED FILE: Do not edit directly, instead edit MemoryChunk.tt
#if !USE_OLD_DATA_CHUNK
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Numerics;

using ThinGin.Core.Common.Enums;

<#
string CLASSNAME = "DataChunk";
string[] TARGET_VALUE_TYPES = new[] { "Byte", "SByte", "UShort", "Short", "UInt", "Int", "Float", "Double" };
string[] TARGET_VALUE_TYPE_ARRAYS = (from sTypeName in TARGET_VALUE_TYPES select $"{sTypeName}[]").ToArray();
#>

namespace ThinGin.Core.Common.Data
{
	public partial class DataChunk : IComparable<DataChunk>, IEquatable<DataChunk>
	{
#region Constants
<#
		Generate_Value_Type_Size_Constant_Declerations(TARGET_VALUE_TYPES);
#>
#endregion

#region Constructors (Series)
<#
		//Generate_Constructor_Value_Type_Overload_Series("public", CLASSNAME, TARGET_VALUE_TYPES, 0, 4, Gen_Ctor__Value_Series_Data_Copy);
		Generate_Constructor_Value_Type_Overload_Series("public", CLASSNAME,
		(from str in TARGET_VALUE_TYPES select new typedef(
			TypeName: str,
			IsArray: false,
			PassByRef: false,
			ReadOnly: false
			)).ToArray(), 
		0, 4, Gen_Ctor__Value_Series_Data_Copy);
#>
#endregion

#region Constructors (Array)
<#
		Generate_Constructor_Value_Type_Overload_Series("public", CLASSNAME, 
		(from str in TARGET_VALUE_TYPES select new typedef(
			TypeName: str,
			IsArray: true,
			PassByRef: true,
			ReadOnly: true
			)).ToArray(), 
		0, 1, Gen_Ctor__Value_Array_Data_Copy);
#>
#endregion

#region Conversions
<#
		Generate_Value_Type_Converter_Series(TARGET_VALUE_TYPES);
#>
#endregion

#region Low-Level Casting
<#
		Generate_Value_Cast_Method_Series(TARGET_VALUE_TYPES);
#>
#endregion

#region Value Retreival
<#
		Generate_Value_Type_Getter_Method_Series(TARGET_VALUE_TYPES);
#>
#endregion

#region IEquatable
		public bool Equals(DataChunk other)
        {
			return CompareTo(other) == 0;
        }
#endregion

#region IComparable
		public int CompareTo(DataChunk other)
        {
			if (other is null)
			{
				throw new ArgumentNullException(nameof(other));
			}

			var TypeLeft = this.Type;
			var TypeRight = other.Type;
<#
			Generate_Value_Type_IComparable_Method_Switch_Block(TARGET_VALUE_TYPES);
#>
			throw new NotImplementedException();
        }
#endregion

#region Low-Level Comparison
<#
		Generate_Value_Type_High_Perf_Comparator_Method_Series(TARGET_VALUE_TYPES);
#>
#endregion

	}
}
#endif